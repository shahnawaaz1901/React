//Blogging App using Hooks
import { useRef, useEffect, useReducer } from "react";
import { db } from "../firebaseinit"; //* Import Firebase Instance
//* For Using the setDoc
import { setDoc, doc, collection } from "firebase/firestore";

//* For using the addDoc
// import { addDoc, collection } from "firebase/firestore";
/*
  For Storing the Data into the Database we need to instance and
  another function which is imported from the fireStore and just
  like the useState hook, where we destructure the array with state 
  and setState called doc and setDoc, doc works as a like state and
  setDoc works as a setState, for inserting the document we need to
  perform some certain operation, because this is I/O kind of operation
  because we call the external database to store or retrieved data 
  this is asynchronous operation, there is no restriction in the 
  storing the data into the database because we have flexibility to 
  pass unstructured data without any restriction, syntax of the data
  storing is the 

  import { doc, setDoc } from "firebase/firestore"; 
  await setDoc(doc(db_Instance, "Collection_Name", "Id"), {
    name: "Los Angeles",
    state: "CA",
    country: "USA"
  });

  One thing that we need to remember if we not selected autoGenerated
  Feature of Id we need to pass the Id manually because it thrown us
  error and if we want to broken the Code into the parts, then syntax
  should be looking like this : 

  import { doc, setDoc } from "firebase/firestore"; 
  const cityRef = doc(db, 'cities', 'BJ');
  setDoc(cityRef, { capital: true }, { merge: true });

  If we want to add document withOut the Id then we can do this by 
  using this syntax which provides auto Generated Id for the each 
  and individual document for the :

import { collection, addDoc } from "firebase/firestore"; 
const docRef = await addDoc(collection(db_Instance, "Collection_Name"), {
  name: "Tokyo",
  country: "Japan"
});
console.log("Document written with ID: ", docRef.id);


*/
function blogsReducer(state, action) {
  switch (action.type) {
    case "ADD": {
      return [action.blogData, ...state];
    }

    case "REMOVE": {
      return state.filter((each, index) => index !== action.blogId);
    }

    default:
      return [];
  }
}

export default function Blog() {
  //* Set State
  // const [blogsData, updateBlogData] = useState([]);
  const [blogsData, dispatch] = useReducer(blogsReducer, []);
  const titleRef = useRef("");
  const contentRef = useRef("");

  //Passing the synthetic event as argument to stop refreshing the page on submit
  async function handleSubmit(e) {
    e.preventDefault();
    const data = {
      title: e.target[0].value,
      content: e.target[1].value,
      createdOn: new Date(),
    };

    document.title = data.title;
    /* 
      Type Indicates which operation we want to perform and another 
      property blogData represents the data which we use to perform 
      the operation we dont require the updateBlogData function anymore

      updateBlogData([{ title, content }, ...blogsData]);
    */
    /*
      If we break down this collection function into parts first 
      argument it takes the fireStore database and next is collection 
      if collection is not present then firestore will create the new 
      collection after that document is stored into that collection 
    */
    //* Using addDoc function
    // await addDoc(collection(db, "blogs"), data);
    /* 
      However we can use setDoc to insert the data into the database
      but in the case of setDoc first we need to create the reference
      by using the doc function which also comes from firebase, now
      question is what is the benefits of using the addDoc or setDoc
      addDoc is used when we only want to store the data into the database
      withOut giving the Id but in the case of setDoc it's our choice
      that we want to give the id or not, if we give the id then first
      firebase will search document corresponding to that id and if id
      not found then it'll create the new document with the Id, this is
      similar to save() keyword of mongoose which do both saving and 
      updating of the document, however we can store the data withOut
      giving any id using the setDoc function
    */
    //* First Create Reference by using the doc function
    /* 
      Here we need to use Collection because because in the doc function
      we need to provide id which is setting to that document because we
      are not passing the id that's why we need to use the collection 
      function we can do withOut the collection function like this by
      passing the id in third argument of doc function
      await setDoc(doc(db, "blogs", "Ashu"), data);
    */
    const docReference = doc(collection(db, "blogs"));
    await setDoc(docReference, data);
    e.target[0].value = "";
    e.target[1].value = "";
    dispatch({ type: "ADD", blogData: data });
  }

  function removeBlog(id) {
    dispatch({ type: "REMOVE", blogId: id });
    // updateBlogData(blogsData.filter((data, index) => index !== id));
  }

  /* 
    Because we only want to called the useEffect only at once when component 
    is render initially because after re rendering we focus the input title 
    box when in the handleSubmit function, so we dont need to focus ony twice
    that's empty array means useEffect called only at once on initial Rendering
    howEver we can remove focus on title from handleSubmit function and put it
    inside the useEffect withOut passing the dependency that's means useEffect
    works as both componentDidMount as well as componentDidUpdate
  */
  useEffect(() => {
    titleRef.current.focus();
  });

  /* 
    We Added the blogsData inside the Dependency Array because is blogsData 
    is getting changed then and only then title of page is change otherwise 
    not 
  */
  useEffect(() => {
    console.log("Inside");
    if (blogsData.length && blogsData[0].title) {
      document.title = blogsData[0].title;
    } else {
      document.title = "No blog";
    }
  }, [blogsData]);
  return (
    <>
      {/* Heading of the page */}
      <h1>Write a Blog!</h1>
      {/* Division created to provide styling of section to the form */}
      <div className="section">
        {/* Form for to write the blog */}
        <form onSubmit={handleSubmit}>
          {/* Row component to create a row for first input field */}
          <Row label="Title">
            <input
              className="input"
              placeholder="Enter the Title of the Blog here.."
              ref={titleRef} //* Reference for Name Field
            />
          </Row>

          {/* Row component to create a row for Text area field */}
          <Row label="Content">
            <textarea
              className="input content"
              placeholder="Content of the Blog goes here.."
              ref={contentRef} //* Reference For Content Field
              required
            />
          </Row>

          {/* Button to submit the blog */}
          <button className="btn">ADD</button>
        </form>
      </div>

      <hr />

      {/* Section where submitted blogs will be displayed */}
      <h2> Blogs </h2>
      {blogsData.map((every, index) => (
        <div key={index} className="blog">
          <h3>{every.title}</h3>
          <p>{every.content}</p>

          <div className="blog-btn" onClick={() => removeBlog(index)}>
            <button className="btn remove">Delete</button>
          </div>
        </div>
      ))}
    </>
  );
}

//Row component to introduce a new row section in the form
function Row(props) {
  const { label } = props;
  return (
    <>
      <label>
        {label}
        <br />
      </label>
      {props.children}
      <hr />
    </>
  );
}
